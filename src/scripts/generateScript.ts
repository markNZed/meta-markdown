/**
 * @module ScriptGenerator
 * 
 * This script generates new scripts based on a hard-coded prompt using a Language Model (LLM).
 * The type of script to generate is specified within the script and can be changed manually by the user.
 * 
 * The first script generated by this tool takes a Markdown file, converts it to an AST (Abstract Syntax Tree),
 * sends the AST to the LLM, and requests a formal description of the Markdown style used. 
 * The generated script outputs the formal description of the Markdown formatting.
 * 
 * The script is designed to be generic, allowing for the generation of new script files when the prompt 
 * is modified. The LLM is utilized to suggest a relevant file name for each new script.
 * 
 * Additionally, this script appends the project's summary from `concatenate_project.txt` to the prompts 
 * sent to the LLM. This ensures that the generated scripts are consistent with the project's features, 
 * adopt the same style as existing scripts, and make full use of the available utilities.
 * 
 * @example
 * To generate the initial script, ensure that `concatenate_project.sh` has been run to create `concatenate_project.txt`, 
 * then execute this script using Deno:
 * 
 * ```bash
 * deno run --allow-read --allow-write --allow-env --allow-net --allow-run ./src/scripts/generateScript.ts
 * ```
 * 
 * Ensure that the necessary permissions are granted for file operations, network access, and running shell commands.
 */

import { callOpenAI, extractCodeBlock } from '@/utils/llm/llm.ts';
import { resolve } from '@std/path';
import { config } from '@/config.ts';
import logger from '@/utils/logger.ts';
import { sanitizeFilename } from '@/utils/misc.ts';

/**
 * Reads the content of a file asynchronously.
 * 
 * @param {string} filePath - The path to the file to read.
 * @returns {Promise<string>} The content of the file as a string.
 * @throws Will throw an error if the file cannot be read.
 */
async function readFileContent(filePath: string): Promise<string> {
    try {
        const content = await Deno.readTextFile(filePath);
        return content;
    } catch (error) {
        logger.error(`Failed to read file at ${filePath}:`, error);
        throw error;
    }
}

/**
 * Extracts the first TypeScript filename from the given text.
 * It looks for content within triple backticks that ends with `.ts`.
 * 
 * @param {string} text - The text from which to extract the filename.
 * @returns {string | null} The extracted filename or null if not found.
 */
function extractFilename(text: string): string | null {
    const regex = /`{1,3}\s*([\w\-]+\.ts)\s*`{1,3}/i;
    const match = regex.exec(text);
    if (match && match[1]) {
        return match[1].trim();
    }
    return null;
}

async function generateScript() {
    // Path to the project summary file
    const projectSummaryPath = resolve(config.rootDir, 'concatenate_project.txt');

    // Read the project summary to append to the prompts
    let projectSummary = '';
    try {
        projectSummary = await readFileContent(projectSummaryPath);
        logger.info('Project summary loaded successfully.');
    } catch (error) {
        logger.error('Proceeding without project summary.');
    }

    // Define the type of script to generate (hard-coded)
    const scriptDescription = `
Create a TypeScript script that takes a Markdown file, converts it to an Abstract Syntax Tree (AST), truncates all text values to a maximum of 128 characters, then sends that AST to the LLM and requests a table of content and uses the commands to replace the current table of content with the new updated table of content.
`;

    // Append project summary to the script description for better context
    const enhancedScriptDescription = `
${scriptDescription}

Project Summary:
${projectSummary}
`;

    // Generate the script code using the LLM
    const scriptCodePrompt = `Based on the following description and project summary, generate a TypeScript script that performs the specified functionality. The script should have a "main" function that is called at the end of the file without any arguments. Do not include any command-line argument parsing or direct script execution checks.

    ${enhancedScriptDescription}
    
    Please ensure the script follows the project's conventions, adopts the same style as existing scripts, and utilizes the available utilities. Include appropriate documentation and error handling.`;

    logger.info('Generating script code using LLM...');
    const scriptCodeResponse = await callOpenAI({
        prompt: scriptCodePrompt,
        requestId: 'generate-script-code',
        configOverrides: {
            model: 'o1-mini',
            maxInputTokens: 32000,
            max_completion_tokens: 32000,
        }
    });

    const scriptCode = extractCodeBlock(scriptCodeResponse as string, 'typescript');
    //const scriptCode = scriptCodeResponse.trim();

    // Generate a relevant file name using the LLM
    const fileNamePrompt = `Based on the following script, suggest a relevant file name including the .ts extension.

${scriptCode}`;

    logger.info('Generating script file name using LLM...');
    const fileNameResponse = await callOpenAI({
        prompt: fileNamePrompt,
        requestId: 'generate-script-filename',
    });

    const extractedFilename = extractFilename(fileNameResponse as string);
    if (!extractedFilename) {
        logger.error('Failed to extract a valid filename from the LLM response.');
        logger.error(`LLM Response: ${fileNameResponse}`);
        return;
    }

    const sanitizedFilename = sanitizeFilename(extractedFilename);

    // Define the file path for the new script
    const scriptsDir = resolve(config.rootDir, 'src', 'scripts');
    const scriptFilePath = resolve(scriptsDir, sanitizedFilename);

    // Write the generated script code to the new file
    try {
        await Deno.writeTextFile(scriptFilePath, scriptCode as string);
        logger.info(`Script generated successfully at ${scriptFilePath}`);
    } catch (error) {
        logger.error(`Failed to write the script to ${scriptFilePath}:`, error);
    }
}

/**
 * Executes a shell command using Deno.Command and handles the output.
 * 
 * @param {string[]} args - The command and its arguments.
 * @returns {Promise<{ success: boolean; errorMessage?: string }>} The result of the command execution.
 */
async function runShellCommand(args: string[]): Promise<{ success: boolean; errorMessage?: string }> {
    try {
        const p = await new Deno.Command("bash", {
            args: args,
            stdout: "piped",
            stderr: "piped",
        }).output();

        const td = new TextDecoder();
        const stdout = td.decode(p.stdout).trim();
        const stderr = td.decode(p.stderr).trim();

        if (p.success) {
            logger.info(`Command "${args.join(' ')}" executed successfully.`);
            return { success: true };
        } else {
            logger.error(`Command "${args.join(' ')}" failed with error: ${stderr || stdout}`);
            return { success: false, errorMessage: stderr || stdout };
        }
    } catch (error: unknown) {
        if (error instanceof Error) {
            logger.error(`Unknown error occurred while running the command: ${error.message}`);
            return { success: false, errorMessage: error.message };
        } else {
            logger.error("Unknown error occurred while running the command.");
            return { success: false, errorMessage: "Unknown error occurred while running the command." };
        }
    }
}

/**
 * Ensures that the `concatenate_project.txt` file exists by running the `concatenate_project.sh` script if necessary.
 * 
 * @returns {Promise<void>}
 */
async function ensureProjectSummary() {
    logger.info('Running concatenate_project.sh...');
    const scriptPath = resolve(config.rootDir, 'concatenate_project.sh');
    const result = await runShellCommand([scriptPath]);

    if (!result.success) {
        logger.error('Failed to execute concatenate_project.sh:', result.errorMessage);
        throw new Error(`concatenate_project.sh failed: ${result.errorMessage}`);
    }
}

// Execute the script generation process
async function main() {
    try {
        await ensureProjectSummary();
        await generateScript();
    } catch (error) {
        if (error instanceof Error) {
            logger.critical('Script generation process failed:', error.message);
        } else {
            logger.critical('Script generation process failed due to an unknown error.');
        }
    }
}

main();
